<html>

<head>
    <title>Dux Avatar Demo</title>
    <style>
        /* Basic styling for the Dux image */
        #background {
            position: fixed;
            top: 20%;
            left: 20%;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 1px;
            align-items: center;



            width: 70%;
            height: 70vh;
            background-image: url('background.png');
            background-size: cover;
            background-position: center;
            border: #6b055a solid 2px;
            z-index: 9999;



           
            /* overflow: hidden; */
           
        }

        #dux {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            /* border: 2px solid #ccc;
                padding: 1px;
                background-color: #f0f0f0; */
            display: grid;
            grid-column: -1/-2;
            grid-row: -2/-1;
            z-index: 1;
            cursor: move;
        }

       /* Image box styles */
#image-box {
    position: relative;
    display: inline-block;
}

/* Handle styles */
.imageHandle {
    position: absolute;
    width: 8px;
    height: 8px;
    background-color: #0e4e46;
    z-index: 10;
    opacity: 0;
}

#image-box:hover .imageHandle{
opacity: 1;
}



/* Corner handles */
#nw { top: -4px; left: -4px; cursor: nw-resize; }
#ne { top: -4px; right: -4px; cursor: ne-resize; }
#sw { bottom: -4px; left: -4px; cursor: sw-resize; }
#se { bottom: -4px; right: -4px; cursor: se-resize; }

/* Edge handles */
#n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
#s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
#e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }
#w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }




        #draggable-resizable-box {
            /* grid-column: -1/-4;
            grid-row: -4/-1; */
            position: absolute;
           
            width: 300px;
            height: 200px;
            background-color: #fdeca6;
            /* border: 2px solid #000; */
            cursor: move;
            resize: none;
            /* To disable native resize */
            transition: 300ms padding;
        }


        /* Resizable handles using data attributes */
        #draggable-resizable-box [data-resize] {
            background-color: #0e4e46;
            position: absolute;
            width: 6px;
            height: 6px;
            z-index: 4;
            opacity: 0;

            transition: 300ms all;
        }

        #draggable-resizable-box:hover [data-resize] {
            opacity: 1;
        }

        #draggable-resizable-box:hover {
            cursor: all-scroll;

            padding: 1px;
            border: 1px solid #081b2d;

        }


        /* Positioning the resize handles at the corners and edges */
        [data-resize="nw"] {
            top: -4px;
            left: -4px;
            cursor: nw-resize;
            margin: 4;
        }

        [data-resize="ne"] {
            top: -4px;
            right: -4px;
            cursor: ne-resize;
        }

        [data-resize="sw"] {
            bottom: -4px;
            left: -4px;
            cursor: sw-resize;
        }

        [data-resize="se"] {
            bottom: -4px;
            right: -4px;
            cursor: se-resize;
        }

        [data-resize="n"] {
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        [data-resize="s"] {
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        [data-resize="e"] {
            right: -4px;
            top: 50%;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        [data-resize="w"] {
            left: -4px;
            top: 50%;
            transform: translateY(-50%);
            cursor: w-resize;
        }

        #talk-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 10px;
            width: 600px;
            z-index: 2;
        }

        #talk-box-header {
            background-color: #f0f0f0;
            padding: 5px;
            border-bottom: 1px solid #ccc;
            cursor: move;
            height: 73px;
        }

        /* Styling for draggable and resizable div */


        /*text */

        #text-box {
            position: absolute;
            top: 30%;
            left: 30%;
            /* width: 300px;
            height: 100px; */
            padding: 13px;

            background-color: transparent;
            border: 2px solid #fafafa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            /* Initial font size */
            text-align: center;
            resize: none;
            /* To disable native resize */
            z-index: 9999;
            border: none;

            transition: 300ms padding;
        }

        #text-box:hover {
            cursor: all-scroll;
            padding: 20px;
            /* border: 1px solid #081b2d; */

        }

        #text-box .resize-handle {
            margin: 8;
            opacity: 0;
            transition: 300ms all;
        }

        #text-box:hover .resize-handle {
            opacity: 1;
            margin: 8;
        }

        .resize-handle {
            position: absolute;
            width: 7px;
            height: 7px;
            background-color: #06615c;
            z-index: 4;
        }

        [contenteditable]:focus {
            outline: 0px solid transparent;
        }

        #text-content {

            border-radius: 70%;
        }

        /* Positioning the resize handles */
        /* .resize-handle.nw1 { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne1 { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw1 { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se1 { bottom: -4px; right: -4px; cursor: se-resize; } */




        /*end of text resize handle */


        /* image */


        .resize-handle {
    position: absolute;
    width: 5px; /* Adjust size as needed */
    height: 5px;
    background-color: #081b2d;
    z-index: 4;
    margin: -5px; /* Offset for better placement */
}

/* Positioning the resize handles */
.resize-handle.nw {
    top: -5px;
    left: -5px;
    cursor: nw-resize;
}

.resize-handle.ne {
    top: -5px;
    right: -5px;
    cursor: ne-resize;
}

.resize-handle.sw {
    bottom: -5px;
    left: -5px;
    cursor: sw-resize;
}

.resize-handle.se {
    bottom: -5px;
    right: -5px;
    cursor: se-resize;
}

.resize-handle.n {
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    cursor: n-resize;
}

.resize-handle.s {
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    cursor: s-resize;
}

.resize-handle.e {
    top: 50%;
    right: -5px;
    transform: translateY(-50%);
    cursor: e-resize;
}

.resize-handle.w {
    top: 50%;
    left: -5px;
    transform: translateY(-50%);
    cursor: w-resize;
}


        #image-content {
            /* display: grid;
            grid-column: -5/-3;
            width: 200%; /* Set smaller default width */
            /* Set smaller default height */
            width: 100%;
            height: 100%;

        }

        #image-content:hover {
            /* display: grid;
            grid-column: -5/-3;
            width: 200%; /* Set smaller default width */
            /* Set smaller default height */
            border: 1px solid #081b2d;


        }

        #image-box {}

        #speakButton {}


        .clone:hover .clonehandle{


            
            opacity: 1;
            margin: 4;

        }
        .clonehandle {
    background-color: #eaf5f3;
    cursor: pointer;
    opacity: 0;
}
.clonehandle1:hover {
    border-radius: 50%;
}
.clone:hover .resize-handle{
  display: none;
}

    </style>
</head>

<body>
    <div id="background">
        <img id="dux" src="images/DuxProHiddle.gif" alt="Dux" style="display:none">



        <div id="talk-box" style="display:none">
            <!-- <div id="talk-box-header" style="background-color:#f7b602">Click here to move</div> -->
            <!-- <textarea rows="2" cols="78" id="talk" placeholder="Type your text here..."></textarea> -->
            <button type="button" id="speakButton" onclick="speakAndChangeImage();">Speak</button><br>
        </div>
        <!-- New draggable and resizable box -->



        <div id="image-box">
            <img src="images/Grid.png" id="image-content" style="cursor: all-scroll;" />
            <!-- Resizable handles -->
            <div id="nw" class="imageHandle"></div>
            <div id="ne" class="imageHandle"></div>
            <div id="sw" class="imageHandle"></div>
            <div id="se" class="imageHandle"></div>
            <div id="n" class="imageHandle"></div>
            <div id="s" class="imageHandle"></div>
            <div id="e" class="imageHandle"></div>
            <div id="w" class="imageHandle"></div>
        </div>
        





        <div id="text-box">
            <div id="text-content" style="cursor: auto;" contenteditable="true">I'm Near East Video Editor</div>
            <!-- Resizable handles -->
            <div class="resize-handle nw"></div>
            <div class="resize-handle ne"></div>
            <div class="resize-handle sw"></div>
            <div class="resize-handle se"></div>
            <div class="resize-handle n"></div>
            <div class="resize-handle s"></div>
            <div class="resize-handle e"></div>
            <div class="resize-handle w"></div>
        </div>


        <div id="draggable-resizable-box">
            <div class="dataresize" data-resize="nw"></div>
            <div class="dataresize" data-resize="ne"></div>
            <div class="dataresize" data-resize="sw"></div>
            <div class="dataresize" data-resize="se"></div>
            <div class="dataresize" data-resize="n"></div>
            <div class="dataresize" data-resize="s"></div>
            <div class="dataresize" data-resize="e"></div>
            <div class="dataresize" data-resize="w"></div>
        </div>


    </div>








    <input type="file" id="imageUpload" accept="image/*" />



    <!-- <script src="https://code.responsivevoice.org/responsivevoice.js?key=NVbGYm7d"></script> -->

    
    <script>
        const box = document.getElementById('draggable-resizable-box');
        const background1 = document.getElementById('background');
        let currentHandle, isResizing = false, isDragging = false;
        let startX, startY, startWidth, startHeight, startTop, startLeft;
    
        const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
    
        const calculateNewDimensions = (dx, dy) => {
            let newWidth = startWidth, newHeight = startHeight;
            let newTop = startTop, newLeft = startLeft;
    
            switch (currentHandle) {
                case 'nw':
                    newWidth -= dx;
                    newHeight -= dy;
                    newLeft += dx;
                    newTop += dy;
                    break;
                case 'ne':
                    newWidth += dx;
                    newHeight -= dy;
                    newTop += dy;
                    break;
                case 'sw':
                    newWidth -= dx;
                    newHeight += dy;
                    newLeft += dx;
                    break;
                case 'se':
                    newWidth += dx;
                    newHeight += dy;
                    break;
                case 'n':
                    newHeight -= dy;
                    newTop += dy;
                    break;
                case 's':
                    newHeight += dy;
                    break;
                case 'e':
                    newWidth += dx;
                    break;
                case 'w':
                    newWidth -= dx;
                    newLeft += dx;
                    break;
            }
    
            // Ensure the new dimensions and positions are within the parent bounds
            const parentRect = background1.getBoundingClientRect();
            newWidth = clamp(newWidth, 20, parentRect.width - newLeft);
            newHeight = clamp(newHeight, 20, parentRect.height - newTop);
            newTop = clamp(newTop, 0, parentRect.height - newHeight);
            newLeft = clamp(newLeft, 0, parentRect.width - newWidth);
    
            return { newWidth, newHeight, newTop, newLeft };
        };
    
        const onMouseMove = (e) => {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const parentRect = background1.getBoundingClientRect();
    
            if (isDragging) {
                let newTop = clamp(startTop + dy, 0, parentRect.height - box.offsetHeight);
                let newLeft = clamp(startLeft + dx, 0, parentRect.width - box.offsetWidth);
                box.style.top = `${newTop}px`;
                box.style.left = `${newLeft}px`;
            } else if (isResizing) {
                const { newWidth, newHeight, newTop, newLeft } = calculateNewDimensions(dx, dy);
    
                if (newWidth > 0 && newHeight > 0) {
                    box.style.width = `${clamp(newWidth, 20, parentRect.width - newLeft)}px`;
                    box.style.height = `${clamp(newHeight, 20, parentRect.height - newTop)}px`;
                    box.style.top = `${newTop}px`;
                    box.style.left = `${newLeft}px`;
                }
            }
        };
    
        const onMouseUp = () => {
            isResizing = false;
            isDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
    
        const onMouseDown = (e) => {
            const style = getComputedStyle(box);
    
            startX = e.clientX;
            startY = e.clientY;
            startWidth = parseFloat(style.width);
            startHeight = parseFloat(style.height);
            startTop = parseFloat(style.top);
            startLeft = parseFloat(style.left);
    
            if (e.target.dataset.resize) {
                isResizing = true;
                currentHandle = e.target.dataset.resize;
            } else {
                isDragging = true;
            }
    
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        };
    
        const makeDraggableAndResizable1 = (element) => {
            element.addEventListener('mousedown', onMouseDown);
        };
    
        makeDraggableAndResizable1(box);
    </script>
    
    

<script>
    // const duplicateBox = () => {
        //     if (getComputedStyle(box).opacity === "1") {
        //         const newBox = box.cloneNode(true);
        //         newBox.style.position = 'absolute';
        //         newBox.style.top = `${Math.random() * 400}px`;
        //         newBox.style.left = `${Math.random() * 400}px`;
        //         newBox.style.zIndex = '10';
        //         background1.appendChild(newBox);
        //         makeDraggableAndResizable1(newBox);
        //     } else {
        //         console.log("Box opacity is not 1, duplication not allowed.");
        //     }
        // };
    
        // document.addEventListener('keydown', (e) => {
        //     if (e.ctrlKey && e.key === 'd') {
        //         e.preventDefault();
        //         duplicateBox();
        //     }
        // });</script>
    
    <script>
        makeResizable1AndDraggable1(document.getElementById("text-box"));
    
        function makeResizable1AndDraggable1(elmnt) {
            let isResizing = false;
            const background = document.getElementById("background");
    
            dragElement1(elmnt);
            makeResizable1(elmnt);
    
            function dragElement1(elmnt) {
                let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    
                elmnt.onmousedown = function (e) {
                    if (!isResizing && e.target !== document.getElementById("text-content")) {
                        dragMouseDown1(e);
                    }
                };
    

    
                function dragMouseDown1(e) {
                    e = e || window.event;
                    e.preventDefault();
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    document.onmouseup = closedragElement1;
                    document.onmousemove = elementDrag1;
                }
    
                function elementDrag1(e) {
                    e = e || window.event;
                    e.preventDefault();
                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;
    
                    let newTop = elmnt.offsetTop - pos2;
                    let newLeft = elmnt.offsetLeft - pos1;
    
                    const backgroundRect = background.getBoundingClientRect();
                    const elmntRect = elmnt.getBoundingClientRect();
    
                    newTop = Math.max(0, Math.min(newTop, backgroundRect.height - elmntRect.height));
                    newLeft = Math.max(0, Math.min(newLeft, backgroundRect.width - elmntRect.width));
    
                    elmnt.style.top = newTop + "px";
                    elmnt.style.left = newLeft + "px";
                }
    
                function closedragElement1() {
                    document.onmouseup = null;
                    document.onmousemove = null;
                }
            }
    
            function makeResizable1(elmnt) {
                const handles = elmnt.querySelectorAll(".resize-handle");
                const content = document.getElementById("text-content");
    
                let initialRect = elmnt.getBoundingClientRect();
                let initialWidth = initialRect.width;
                let initialFontSize = parseInt(window.getComputedStyle(content).fontSize, 10);
    
                handles.forEach(function (handle) {



          

                    handle.addEventListener("mousedown", function (e) {
                        e.preventDefault();
                        isResizing = true;
                        const rect = elmnt.getBoundingClientRect();
                        const initialX = e.clientX;
                        const initialY = e.clientY;
                        const initialBoxWidth = rect.width;
                        const initialBoxHeight = rect.height;
                        const startLeft = elmnt.offsetLeft;
                        const startTop = elmnt.offsetTop;
    
                        document.onmousemove = function (e) {
                            const dx = e.clientX - initialX;
                            const dy = e.clientY - initialY;
    
                            const { newWidth, newHeight, newTop, newLeft } = calculateNewDimensions(dx, dy);
    
                            if (newWidth > 20 && newHeight > 20) {
                                elmnt.style.width = newWidth + "px";
                                elmnt.style.height = newHeight + "px";
                                elmnt.style.top = newTop + "px";
                                elmnt.style.left = newLeft + "px";
    
                                const widthRatio = newWidth / initialWidth;
                                const newFontSize = initialFontSize * widthRatio;
                                content.style.fontSize = newFontSize + "px";
                            }
                        };
    
                        document.onmouseup = function () {
                            document.onmousemove = null;
                            document.onmouseup = null;
                            isResizing = false;
                        };
    
                        function calculateNewDimensions(dx, dy) {
                            let newWidth = initialBoxWidth, newHeight = initialBoxHeight;
                            let newTop = startTop, newLeft = startLeft;
    
                            if (handle.classList.contains("nw")) {
                                newWidth -= dx;
                                newHeight -= dy;
                                newLeft += dx;
                                newTop += dy;
                            } else if (handle.classList.contains("ne")) {
                                newWidth += dx;
                                newHeight -= dy;
                                newTop += dy;
                            } else if (handle.classList.contains("sw")) {
                                newWidth -= dx;
                                newHeight += dy;
                                newLeft += dx;
                            } else if (handle.classList.contains("se")) {
                                newWidth += dx;
                                newHeight += dy;
                            } else if (handle.classList.contains("n")) {
                                newHeight -= dy;
                                newTop += dy;
                            } else if (handle.classList.contains("s")) {
                                newHeight += dy;
                            } else if (handle.classList.contains("e")) {
                                newWidth += dx;
                            } else if (handle.classList.contains("w")) {
                                newWidth -= dx;
                                newLeft += dx;
                            }
    
                            return { newWidth, newHeight, newTop, newLeft };
                        }
                    });
                });
            }
        }
    </script>
    
   
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const imageBox = document.getElementById("image-box");
            const background = document.getElementById("background");
    
            let isDragging = false;
            let isResizing = false;
            let startX, startY, startTop, startLeft, startWidth, startHeight, startHandle;
    
            const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    
            const calculateNewDimensions = (dx, dy) => {
    let newWidth = startWidth;
    let newHeight = startHeight;
    let newTop = startTop;
    let newLeft = startLeft;

    const parentRect = background.getBoundingClientRect();

    if (startHandle === "nw") {
        newWidth = startWidth - dx;
        newHeight = startHeight - dy;
        newTop = clamp(startTop + dy, 0, startTop + startHeight - 20);
        newLeft = clamp(startLeft + dx, 0, startLeft + startWidth - 20);
    } else if (startHandle === "ne") {
        newWidth = startWidth + dx;
        newHeight = startHeight - dy;
        newTop = clamp(startTop + dy, 0, startTop + startHeight - 20);
    } else if (startHandle === "sw") {
        newWidth = startWidth - dx;
        newHeight = startHeight + dy;
        newLeft = clamp(startLeft + dx, 0, startLeft + startWidth - 20);
    } else if (startHandle === "se") {
        newWidth = startWidth + dx;
        newHeight = startHeight + dy;
    } else if (startHandle === "n") {
        newHeight = startHeight - dy;
        newTop = clamp(startTop + dy, 0, startTop + startHeight - 20);
    } else if (startHandle === "s") {
        newHeight = startHeight + dy;
    } else if (startHandle === "e") {
        newWidth = startWidth + dx;
    } else if (startHandle === "w") {
        newWidth = startWidth - dx;
        newLeft = clamp(startLeft + dx, 0, startLeft + startWidth - 20);
    }

    // Ensure width and height don't cause the box to exceed the parent's bounds
    newWidth = clamp(newWidth, 20, parentRect.width - newLeft);
    newHeight = clamp(newHeight, 20, parentRect.height - newTop);
    newTop = clamp(newTop, 0, parentRect.height - newHeight);
    newLeft = clamp(newLeft, 0, parentRect.width - newWidth);

    return { newWidth, newHeight, newTop, newLeft };
};

    
            const onMouseDown = (e, handleId) => {
                e.preventDefault();
                isResizing = !!handleId;
                isDragging = !handleId;
    
                startX = e.clientX;
                startY = e.clientY;
                startTop = imageBox.offsetTop;
                startLeft = imageBox.offsetLeft;
                startWidth = imageBox.offsetWidth;
                startHeight = imageBox.offsetHeight;
                startHandle = handleId;
    
                document.addEventListener("mousemove", onMouseMove);
                document.addEventListener("mouseup", onMouseUp);
            };
    
            const onMouseMove = (e) => {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
    
                if (isResizing) {
                    const { newWidth, newHeight, newTop, newLeft } = calculateNewDimensions(dx, dy);
                    imageBox.style.width = `${newWidth}px`;
                    imageBox.style.height = `${newHeight}px`;
                    imageBox.style.top = `${newTop}px`;
                    imageBox.style.left = `${newLeft}px`;
                } else if (isDragging) {
                    const parentRect = background.getBoundingClientRect();
                    const newTop = clamp(startTop + dy, 0, parentRect.height - imageBox.offsetHeight);
                    const newLeft = clamp(startLeft + dx, 0, parentRect.width - imageBox.offsetWidth);
                    imageBox.style.top = `${newTop}px`;
                    imageBox.style.left = `${newLeft}px`;
                }
            };
    
            const onMouseUp = () => {
                isDragging = false;
                isResizing = false;
                document.removeEventListener("mousemove", onMouseMove);
                document.removeEventListener("mouseup", onMouseUp);
            };
    
            // Adding drag functionality to the box
            imageBox.addEventListener("mousedown", (e) => {
                if (!e.target.classList.contains("imageHandle")) {
                    onMouseDown(e, null);
                }
            });
    
            // Adding resize handles
            const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'];
            handles.forEach((handleId) => {
                const handle = document.getElementById(handleId);
                handle.addEventListener("mousedown", (e) => onMouseDown(e, handleId));
            });
        });
    </script>


<script>
    const background = document.getElementById('background');
    let hoveredElement = null;
    let isCtrlPressed = false;

    // Utility function to make elements draggable and resizable
    const makeDraggableAndResizable = (element) => {
        const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
        let isResizing = false, isDragging = false;
        let startX, startY, startWidth, startHeight, startTop, startLeft;
        let currentHandle;

        const onMouseMove = (e) => {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const parentRect = background.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();

            if (isDragging) {
                let newTop = clamp(startTop + dy, 0, parentRect.height - elementRect.height);
                let newLeft = clamp(startLeft + dx, 0, parentRect.width - elementRect.width);
                element.style.top = `${newTop}px`;
                element.style.left = `${newLeft}px`;
            } else if (isResizing) {
                let newWidth = startWidth, newHeight = startHeight, newTop = startTop, newLeft = startLeft;

                switch (currentHandle) {
                    case 'nw':
                        newWidth = startWidth - dx;
                        newHeight = startHeight - dy;
                        newLeft = startLeft + dx;
                        newTop = startTop + dy;
                        break;
                    case 'ne':
                        newWidth = startWidth + dx;
                        newHeight = startHeight - dy;
                        newTop = startTop + dy;
                        break;
                    case 'sw':
                        newWidth = startWidth - dx;
                        newHeight = startHeight + dy;
                        newLeft = startLeft + dx;
                        break;
                    case 'se':
                        newWidth = startWidth + dx;
                        newHeight = startHeight + dy;
                        break;
                }

                if (newWidth > 10 && newHeight > 10) {
                    element.style.width = `${newWidth}px`;
                    element.style.height = `${newHeight}px`;
                    element.style.top = `${newTop}px`;
                    element.style.left = `${newLeft}px`;
                }
            }
        };

        const onMouseUp = () => {
            isDragging = false;
            isResizing = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };

        const onMouseDown = (e) => {
            if (e.target.dataset.resize) {
                isResizing = true;
                currentHandle = e.target.dataset.resize;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseFloat(getComputedStyle(element).width);
                startHeight = parseFloat(getComputedStyle(element).height);
                startTop = parseFloat(getComputedStyle(element).top);
                startLeft = parseFloat(getComputedStyle(element).left);
            } else {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startTop = parseFloat(getComputedStyle(element).top);
                startLeft = parseFloat(getComputedStyle(element).left);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        };

        element.addEventListener('mousedown', onMouseDown);
    };

    // Duplicate and initialize functionality for new elements
    const duplicateElement = () => {
        if (hoveredElement && hoveredElement.id !== "background") {
            const clone = hoveredElement.cloneNode(true);
            clone.setAttribute("class","clone")
            clone.style.position = "absolute";
            
            clone.style.left = `${hoveredElement.offsetLeft + 10}px`;
            clone.style.top = `${hoveredElement.offsetTop + 10}px`;
            clone.style.zIndex = "10";
            background.appendChild(clone);
            makeDraggableAndResizable(clone);

            // Add resizing handles dynamically if not present
            ['nw', 'ne', 'sw', 'se'].forEach((direction) => {
                const handle = document.createElement('div');
                
                

                handle.dataset.resize = direction;

                handle.className = "clonehandle clonehandle1";
                handle.style.position = 'absolute';
                handle.style.width = '7px';
                handle.style.height = '7px';

               
                handle.setAttribute("display","none")
              
                handle.style.background = '#0e4e46';
                handle.style.cursor = `${direction}-resize`;

                switch (direction) {
                    case 'nw':
                        handle.style.top = '-5px';
                        handle.style.left = '-5px';
                        break;
                    case 'ne':
                        handle.style.top = '-5px';
                        handle.style.right = '-5px';
                        break;
                    case 'sw':
                        handle.style.bottom = '-5px';
                        handle.style.left = '-5px';
                        break;
                    case 'se':
                        handle.style.bottom = '-5px';
                        handle.style.right = '-5px';
                        break;
                }

                clone.appendChild(handle);
            });
        }
    };

    document.addEventListener("mouseover", (e) => {
        if (e.target.matches("img, div") && e.target.id !== "background") {
            hoveredElement = e.target;
        }
    });

    document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === 'd') {
            e.preventDefault();
            duplicateElement();
        }
    });
</script>


</body>

</html>